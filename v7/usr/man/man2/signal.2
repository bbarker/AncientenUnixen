.TH SIGNAL 2 
.SH NAME
signal \- catch or ignore signals
.SH SYNOPSIS
.B #include <signal.h>
.PP
.B (*signal(sig, func))()
.br
.B (*func)();
.SH DESCRIPTION
A signal
is generated by some abnormal event,
initiated either by user at a typewriter (quit, interrupt),
by a program error (bus error, etc.),
or by request of another program (kill).
Normally all signals
cause termination of the receiving process,
but a
.I signal
call allows them either to be ignored
or to cause an interrupt to a specified location.
Here is the list of signals with names as in
the include file.
.LP
.nf
.ta \w'SIGMMMM 'u +\w'15*  'u
SIGHUP	1	hangup
SIGINT	2	interrupt
SIGQUIT	3*	quit
SIGILL	4*	illegal instruction (not reset when caught)
SIGTRAP	5*	trace trap (not reset when caught)
SIGIOT	6*	IOT instruction
SIGEMT	7*	EMT instruction
SIGFPE	8*	floating point exception
SIGKILL	9	kill (cannot be caught or ignored)
SIGBUS	10*	bus error
SIGSEGV	11*	segmentation violation
SIGSYS	12*	bad argument to system call
SIGPIPE	13	write on a pipe or link with no one to read it
SIGALRM	14	alarm clock
SIGTERM	15	software termination signal
	16	unassigned
.fi
.PP
The starred signals in the list above cause a core image
if not caught or ignored.
.PP
If
.I func
is SIG_DFL, the default action
for signal
.I sig
is reinstated; this default is termination,
sometimes with a core image.
If
.I func
is SIG_IGN the signal is ignored.
Otherwise
when the signal occurs
.I func
will be called with the
signal number as argument.
A return from the function will
continue the process at the point it was interrupted.
Except as indicated,
a signal is reset to SIG_DFL after being caught.
Thus if it is desired to
catch every such signal,
the catching routine must
issue another
.I signal
call.
.PP
When a caught signal occurs
during certain system calls, the call terminates prematurely.
In particular this can occur
during a
.I read
or
.IR write (2)
on a slow device (like a typewriter; but not a file);
and during
.I pause
or
.IR wait (2).
When such a signal occurs, the saved user status
is arranged in such a way that when return from the
signal-catching takes place, it will appear that the
system call returned an error status.
The user's program may then, if it wishes,
re-execute the call.
.PP
The value of
.I signal
is the previous (or initial)
value of
.I func
for the particular signal.
.PP
After a
.IR  fork (2)
the child inherits
all signals.
.IR  Exec (2)
resets all
caught signals to default action.
.SH "SEE ALSO"
kill(1), kill(2),
ptrace(2),
setjmp(3)
.SH DIAGNOSTICS
The value (int)\-1 is returned if the
given signal is out of range.
.SH BUGS
If a repeated signal arrives before the last one can be
reset, there is no chance to catch it.
.PP
The type specification of the routine and its
.I func
argument are problematical.
.SH ASSEMBLER
(signal = 48.)
.br
.B sys  signal; sig; label
.br
(old label in r0)
.PP
If
.I label
is 0,
default action is reinstated.
If
.I label
is odd, the signal is ignored.
Any other even
.I label
specifies an address in the process
where an interrupt is simulated.
An RTI or RTT instruction will return from the
interrupt.
