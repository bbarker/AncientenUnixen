.pl 11i
.hc %
.ll 6.5i
.ps 16
.vs 18p
.sp 1.5i
.ce
UNIX Assembler Reference Manual
.sp 1.5
.ft I
.ps 12
.ce
Dennis M. Ritchie
.ce 2
.sp .5
Bell Laboratories
Murray Hill, New Jersey
.sp 2
.ps 10
.vs 11p
.ft R
.de pg
.sp .5
..
.de et
.ft
.pg
..
.de ms
.ne 3
.sp
..
.de ul
.ne 4
.sp
.ft B
..
.de fo
'bp
..
.de he
'tl '-'''
'sp 0.5i
.ft I
.if o .tl '''Assembler Manual - %'
.if e .tl 'Assembler Manual - %'''
.ft
'sp 0.4i
.ns
..
.wh -1i fo
.wh 0 he
.ul
0.  Introduction
.et
This document describes the usage and input syntax
of the \s8UNIX PDP\s10-11 assembler \fIas\fP.  The details
of the \s8PDP\s10-11 are not described; consult the \s8DEC\s10 
documents ``\s8PDP\s10-11/20 Handbook'' and ``\s8PDP\s10-11/45 Handbook.''
.pg
The input syntax of the \s8UNIX\s10 assembler is generally
similar to that of the \s8DEC\s10 assembler \s8PAL\s10-11\s8R\s10, although
its internal workings and output format
are unrelated.
It may be useful to read the publication \s8DEC\s10-11-\s8ASDB\s10-\s8D\s10,
which describes \s8PAL\s10-11\s8R\s10, although naturally
one must use care in assuming that its rules apply
to \fIas\fP.
.pg
\fIAs\fP is a rather ordinary two-pass assembler without
macro capabilities.
It produces an output file which contains
relocation information and a complete
symbol table;
thus the output is acceptable to the \s8UNIX\s10 link-editor
\fIld\fP, which
may be used to combine the outputs of several
assembler runs and to obtain
object programs from libraries.
The output format has been designed
so that if a program contains no unresolved
ref%er%ences to external symbols, it is executable
without further processing.
.ul
1.  Usage
.et
\fIas\fP is used as follows:
.sp
.ft B
      as  \fR[\fB  _  \fR]  \fIfile\s6\d1\u\s10  .\|.\|.
.sp
.ft R
If the optional ``_'' argument is
given, all undefined symbols
in the current assembly will be made undefined-external.
See the \fB.globl\fR directive below.
.pg
The other arguments name files
which are concatenated and assembled.
Thus programs may be written in several
pieces and assembled together.
.pg
The output of the assembler is placed on
the file \fIa.out\fR in the current directory.
If there were no unresolved
external ref%er%ences, and no errors detected,
\fIa.out\fP is made executable; otherwise, if it is
produced at all, it is made non-executable.
.ul
2.  Lexical conventions
.et
Assembler tokens include identifiers (alternatively, ``symbols'' or ``names''),
temporary symbols,
constants, and operators.
.ms
2.1  Identifiers
.pg
An identifier consists of a sequence of alphanumeric characters (including
period ``\|\fB.\fR\|'', underscore ``\(ul'',
and tilde ``~''
as alphanumeric)
of which the first may not
be numeric.
Only the first eight characters are significant.
When a name begins with a tilde, the tilde is discarded
and that occurrence of the identifier generates
a unique entry in the symbol table which can match
no other occurrence of the identifier.
This feature is used
by the C compiler to place names of local variables
in the output symbol table
without having to worry
about 
making them unique.
.ms
2.2  Temporary symbols
.pg
A temporary symbol consists of a digit followed by ``f\|'' or
``b''.
Temporary symbols are discussed fully in \(sc5.1.
.ms
2.3  Constants
.pg
An octal constant consists of a sequence of digits; ``8'' and
``9'' are taken to have octal value 10 and 11.
The constant
is truncated to 16 bits and interpreted in two's complement
notation.
.pg
A decimal constant consists of a sequence of digits terminated
by a decimal point ``\fB.\fR''.  The magnitude of the constant should be
representable in 15 bits; i.e., be less than 32,768.
.pg
A single-character constant consists of a single quote ``\|\(fm\|''
followed by an \s8ASCII\s10 character not a new-line.
Certain dual-character escape sequences
are acceptable in place of the \s8ASCII\s10 character to represent
new-line and other non-graphics (see \fIString state%ments\fP, \(sc5.5).
The constant's value has the code for the
given character in the least significant
byte of the word and is null-padded on the left.
.pg
A double-character constant consists of a double
quote ``\|"\|'' followed by a pair of \s8ASCII\s10 characters
not including new-line.
Certain dual-character escape sequences are acceptable
in place of either of the \s8ASCII\s10 characters
to represent new-line and other non-graphics
(see \fIString state%ments\fR, \(sc5.5).
The constant's value has the code for the first
given character in the least significant
byte and that for the second character in
the most significant byte.
.ms
2.4  Operators
.pg
There are several single- and double-character
operators; see \(sc6.
.ms
2.5  Blanks
.pg
Blank and tab characters
may be interspersed freely between tokens, but may
not be used within tokens (except character constants).
A blank or tab is required to separate adjacent
identifiers or constants not otherwise separated.
.ms
2.6  Comments
.pg
The character ``\|/\|'' introduces a comment, which extends
through the end of the line on which it appears.
Comments are ignored by the assembler.
.ul
3.  Segments
.et
Assembled code and data
fall into three segments: the text segment, the data segment, and the bss segment.
The text segment is the one in which the assembler begins,
and it is the one into which instructions are typically placed.
The \s8UNIX\s10 system will, if desired,
enforce the purity of the text segment of programs by
trapping write operations
into it.
Object programs produced by the assembler must be processed
by the link-editor \fIld\fR
(using its ``_n'' flag)
if the text segment is to be write-protected.
A single copy of the text
segment is shared among all processes
executing such a program.
.pg
The data segment is available for placing
data or instructions which
will be modified during execution.
Anything which may go in the text segment may be put
into the data segment.
In programs with write-protected, sharable text segments,
data segment contains the initialized but variable
parts of a program.
If the text segment is not pure, the data segment begins
immediately after the
text segment;
if the text segment is pure, the data segment begins at the lowest
8K byte boundary after the text segment.
.pg
The bss segment may not contain any explicitly initialized code
or data.
The length of the bss segment (like that of text or data)
is determined by the high-water mark of the location counter
within it.
The bss segment is actually an extension of
the data segment and begins immediately after it.
At the start of execution of a program, the bss segment
is set to 0.
Typically the bss segment is set up
by state%ments exemplified by
.sp
	lab\fB: .\fR = \fB.\fR+10
.sp
The advantage in using the bss segment
for storage that starts off empty is that the initialization
information need not be stored in the output file.
See also \fILocation counter\fP and \fIAssignment state%ments\fP
below.
.ul
4.  The location counter
.et
One special symbol, ``\|\fB.\fP\|'', is the location counter.
Its value at any time is the offset
within the appropriate segment of the start of
the state%ment in which it appears.
The location counter may be assigned to,
with the restriction that the
current segment may not change;
furthermore,
the value of ``\|\fB.\fP\|'' may not decrease.
If the effect of the assignment is to increase the value of ``\|\fB.\fP\|'',
the required number of null bytes are generated
(but see \fISegments\fP above).
.ul
5.  Statements
.et
A source program is composed of a sequence of
\fIstate%ments\fP.
Statements are separated either by new-lines
or by semicolons.
There are five kinds of state%ments: null state%ments,
expression state%ments, assignment state%ments,
string state%ments,
and keyword state%ments.
.pg
Any kind of state%ment may be preceded by
one or more labels.
.ms
5.1  Labels
.pg
There are two kinds of label:
name labels and numeric labels.
A name label consists of a name followed
by a colon (\|:\|).
The effect of a name label is to assign the current
value and type of the location counter ``\|\fB.\fP\|''
to the name.
An error is indicated in pass 1 if the
name is already defined;
an error is indicated in pass 2 if the ``\|\fB.\fP\|''
value assigned changes the definition
of the label.
.pg
A numeric label consists of a digit \fI0\fR to \fI9\fR followed by a colon (\|:\|).
Such a label serves to define temporary
symbols of the form ``\fIn\fR\|b'' and ``\fIn\fR\|f\|'', where \fIn\fR is
the digit of the label.
As in the case of name labels, a numeric label assigns
the current value and type of ``\|\fB.\fP\|'' to the temporary
symbol.
However, several numeric labels with the same
digit may be used within the same assembly.
Ref%er%ences of the form ``\fIn\fR\|f\|'' refer to the first
numeric label ``\fIn\|\fR:'' \fIf\fR\|orward from the ref%er%ence;
``\fIn\fRb'' symbols refer to the first ``\fIn\fR\|:'' label
\fIb\fRackward from the ref%er%ence.
This sort of temporary label was introduced by Knuth
[\fIThe Art of Computer Programming, Vol I: Fundamental Algorithms\|\fR].
Such labels tend to conserve both the symbol table
space of the assembler and the
inventive powers of the programmer.
.ms
5.2  Null state%ments
.pg
A null state%ment is an empty state%ment (which may, however,
have labels).
A null state%ment is ignored by the assembler.
Common examples of null state%ments are empty
lines or lines containing only a label.
.ms
5.3  Expression state%ments
.pg
An expression state%ment consists of an arithmetic
expression not beginning with
a keyword.
The assembler computes its (16-bit) value
and places it in the output stream, together with the
appropriate relocation bits.
.ms
5.4  Assignment state%ments
.pg
An assignment state%ment consists of an identifier, an equals sign (\|=\|),
and an expression.
The value and type of the expression are assigned to
the identifier.
It is not required that the type or value be
the same in pass 2 as in pass 1, nor is it an
error to redefine any symbol by assignment.
.pg
Any external attribute of the expression is lost across
an assignment.
This means that it is not possible to declare a global
symbol by assigning to it, and that it is impossible
to define a symbol to be offset from a non-locally
defined global symbol.
.pg
As mentioned,
it is permissible to assign to the
location counter ``\|\fB.\fP\|''.
It is required, however, that the type of
the expression assigned be of the same type
as ``\|\fB.\fP\|'',
and it is forbidden to decrease the value
of ``\fB\|.\|\fR''.
In practice, the most common assignment to ``\|\fB.\fP\|'' has the form
``.\|=\|.\|+\|\fIn\fR''
for some number \fIn;\fR this has the effect of generating
\fIn\fR null bytes.
.ms
5.5  String state%ments
.pg
A string state%ment generates a sequence of bytes containing \s8ASCII\s10 characters.
A string state%ment consists of a left string quote ``<''
followed by a sequence of \s8ASCII\s10 characters not including newline,
followed by a right string quote ``>''.
Any of the \s8ASCII\s10 characters may
be replaced by a two-character escape sequence to represent
certain non-graphic characters, as follows:
.sp
.ta .5i 1.5i 2.0i
.ne 9
.nf
	\\n	\s8NL\s10	(012)
	\\t	\s8HT\s10	(011)
	\\e	\s8EOT\s10	(004)
	\\0	\s8NUL\s10	(000)
	\\r	\s8CR\s10	(015)
	\\a	\s8ACK\s10	(006)
	\\p	\s8PFX\s10	(033)
	\\\\	\\
	\\>	>
.sp
.fi
.in 0
The last two are included so that the escape character
and the right string quote may be represented.
The same escape sequences
may also be used within single- and double-character
constants (see \(sc2.3 above).
.ms
5.6  Keyword state%ments
.pg
Keyword state%ments are numerically the most common type,
since most machine instructions are of this
sort.
A keyword state%ment begins with one of the many predefined
keywords of the assembler;
the syntax of the remainder depends
on the keyword.
All the keywords are listed below with the syntax they require.
.ul
6.  Expressions
.et
An expression is a sequence of symbols representing a value.
Its constituents are identifiers, constants, temporary symbols,
operators, and brackets.
Each expression has a type.
.pg
All operators in expressions are fundamentally binary in
nature; if an operand is missing on the left, a 0
of absolute type is assumed.
Arithmetic
is two's complement and has 16 bits of precision.
All operators have equal precedence, and expressions
are evaluated
strictly left to right except for the effect
of brackets.
.ms
6.1  Expression operators
.pg
The operators are:
.sp
.in 8
.ta 3 8
.ti 0
	(blank)	when there is no operator between
operands, the effect is
exactly the same as if a ``+'' had appeared.
.pg
.ti 0
	+	addition
.pg
.ti 0
	_	subtraction
.pg
.ti 0
	*	multiplication
.pg
.ti 0
	\\\(sl	division (note that plain ``\|/\|'' starts a comment)
.pg
.ti 0
	&	bitwise \fBand\fR
.pg
.ti 0
	\|\|\(bv	bitwise \fBor\fR
.pg
.ti 0
	>>	logical right shift
.pg
.ti 0
	<<	logical left shift
.pg
.hc
.ti 0
	%	modulo
.pg
.hc %
.ti 0
	!	\fIa\fR\|!\|\fIb\fR is \fIa \fBor \fR(\|\fBnot \fIb\fR\|);
i.e., the \fBor\fR of the first operand and
the one's complement of the second; most common use is
as a unary.
.pg
.ti 0
	^	result has the value of first operand and the type of the second;
most often used to define new machine instructions
with syntax identical to existing instructions.
.sp
.in 0
Expressions may be grouped by use of square brackets ``\|[\|\|]\|''.
(Round parentheses are reserved for address modes.)
.ms
6.2  Types
.pg
The assembler deals with a number of types
of expressions.  Most types
are attached to keywords and used to select the
routine which treats that keyword.  The types likely
to be met explicitly are:
.sp 1
.in 6
.ti 3
undefined
.br
Upon first encounter, each symbol is undefined.
It may become undefined if it is assigned an undefined expression.
It is an error to attempt to assemble an undefined
expression in pass 2; in pass 1, it is not (except that
certain keywords require operands which are not undefined).
.pg
.ti 3
undefined external
.br
A symbol which is declared \fB.globl\fR but not defined
in the current assembly is an undefined
external.
If such a symbol is declared, the link editor \fIld\fR
must be used to load the assembler's output with
another routine that defines the undefined ref%er%ence.
.pg
.ti 3
absolute
.br
An absolute symbol is one defined ultimately from a constant.
Its value is unaffected by any possible future applications
of the link-editor to the output file.
.pg
.ti 3
text
.br
The value of a text symbol is measured
with respect to the beginning of the text segment of the program.
If the assembler output is link-edited, its text
symbols may change in value
since the program need
not be the first in the link editor's output.
Most text symbols are defined by appearing as labels.
At the start of an assembly, the value of ``\|\fB.\fP\|'' is text 0.
.pg
.ti 3
data
.br
The value of a data symbol is measured
with respect to the origin of the data segment of a program.
Like text symbols, the value of a data symbol may change
during a subsequent link-editor run since previously
loaded programs may have data segments.
After the first \fB.data\fR state%ment, the value of ``\|\fB.\fP\|''
is data 0.
.pg
.ti 3
bss
.br
The value of a bss symbol is measured from
the beginning of the bss segment of a program.
Like text and data symbols, the value of a bss symbol
may change during a subsequent link-editor
run, since previously loaded programs may have bss segments.
After the first \fB.bss\fR state%ment, the value of ``\|\fB.\fP\|'' is bss 0.
.pg
.ti 3
external absolute, text, data, or bss
.br
symbols declared \fB.globl\fR
but defined within an assembly as absolute, text, data, or bss
symbols may be used exactly as if they were not
declared \fB.globl\fR; however, their value and type are available
to the link editor so that the program may be loaded with others
that ref%er%ence these symbols.
.pg
.ti 3
register
.br
The symbols
.ta 6
.pg
.nf
	\fBr0\fR  .\|.\|. \fBr5
	fr0\fR  .\|.\|. \fBfr5
	sp
	pc
.ft R
.fi
.pg
are predefined
as register symbols.
Either they or symbols defined from them must
be used to refer to the six general-purpose,
six floating-point, and
the 2 special-purpose machine registers.
The behavior of the floating register names
is identical to that of the corresponding
general register names; the former
are provided as a mnemonic aid.
.pg
.ti 3
other types
.br
Each keyword known to the assembler has a type which
is used to select the routine which processes
the associated keyword state%ment.
The behavior of such symbols
when not used as keywords is the same as if they were absolute.
.in 0
.ms
6.3  Type propagation in expressions
.pg
When operands are combined by expression operators,
the result has a type which depends on the types
of the operands and on the operator.
The rules involved are complex to state but
were intended to be sensible and predictable.
For purposes of expression evaluation the
important types are
.pg
.ta 1i
.nf
	undefined
	absolute
	text
	data
	bss
	undefined external
	other
.fi
.pg
The combination rules are then:
If one of the operands
is undefined, the result is undefined.
If both operands are absolute, the result is absolute.
If an absolute is combined with one of the ``other types''
mentioned above,
or with a register expression, the result
has the register or other type.
As a consequence,
one can refer to r3 as ``r0+3''.
If two operands of ``other type'' are combined,
the result has the
numerically larger type
(not that this fact is very useful, since the values are not made public).
An ``other type'' combined with an explicitly
discussed type other than absolute
acts like an absolute.
.pg
Further rules applying to particular operators
are:
.sp
.in 7
.ta 3 7
.ti 0
	+	If one operand is text-, data-, or bss-segment
relocatable, or is an undefined external,
the result has the postulated type and the other operand
must be absolute.
.pg
.ti 0
	_	If the first operand is a relocatable
text-, data-, or bss-segment symbol, the second operand
may be absolute (in which case the result has the
type of the first operand);
or the second operand may have the same type
as the first (in which case the result is absolute).
If the first operand is external undefined, the second must be
absolute.
All other combinations are illegal.
.pg
.ti 0
	^	This operator follows no other rule than
that the result has the value
of the first operand and the type of the second.
.pg
.ti 0
	others	It is illegal to apply these operators to any but absolute
symbols.
.in 0
.ul
7.  Pseudo-operations
.et
The keywords listed below introduce
state%ments which generate data in unusual forms or
influence the later operations of the assembler.
The metanotation
.pg
	[ stuff ] .\|.\|.
.pg
means that 0 or more instances of the given stuff may appear.
Also, boldface tokens are literals, italic words
are substitutable.
.ms
7.1  \fB.byte  \fIexpression  \fR[  \fB, \fIexpression \fR]  .\|.\|.
.pg
The \fIexpression\fRs in the comma-separated
list are truncated to 8 bits and assembled in successive
bytes.
The expressions must be absolute.
This state%ment and the string state%ment above are the only ones
which assemble data one byte at at time.
.ms
7.2  \fB.even\fR
.pg
If the location counter ``\|\fB.\fP\|'' is odd, it is advanced by one
so the next state%ment will be assembled
at a word boundary.
.ms
7.3  \fB.if  \fIexpression\fR
.pg
The \fIexpression\fR must be absolute and defined in pass 1.
If its value is nonzero, the \fB.if\fR is ignored; if zero,
the state%ments between the \fB.if\fR and the matching \fB.endif\fR
(below) are ignored.
.li
\fB.if\fR may be nested.
The effect of \fB.if\fR cannot extend beyond
the end of the input file in which it appears.
(The state%ments are not totally ignored, in
the following
sense: \fB.if\fRs and \fB.endif\fRs are scanned for, and
moreover all names
are entered in the symbol table.
Thus names occurring only inside
an \fB.if\fR
will show up as undefined if the symbol
table is listed.)
.ms
7.4  \fB.endif\fR
.pg
This state%ment marks the end of a conditionally-assembled section of code.
See \fB.if\fR above.
.ms
7.5  \fB.globl  \fIname  \fR[  \fB,\fI  name  \fR]  .\|.\|.
.pg
This state%ment makes the \fInames\fR external.
If they are otherwise defined (by assignment or
appearance as a label)
they act within the assembly exactly as if
the \fB.globl\fR state%ment were not given; however,
the link editor \fIld\fR may be used
to combine this routine with other routines that refer
these symbols.
.pg
Conversely, if the given symbols are not defined
within the current assembly, the link editor
can combine the output of this assembly
with that of others which define the symbols.
.pg
As discussed in \(sc1, it is possible to force
the assembler to make all otherwise
undefined symbols external.
.ms
.ne 5
7.6  \fB.text\fR
.br
7.7  \fB.data\fR
.br
7.8  \fB.bss\fR
.br
.pg
These three pseudo-operations cause the
assembler to begin assembling into the text, data, or
bss segment respectively.
Assembly starts in the text segment.
It is forbidden to assemble any
code or data into the bss segment, but symbols may
be defined and ``\|\fB.\fP\|'' moved about by assignment.
.ms
7.9  \fB.comm\fI  name  \fB,  \fIexpression\fR
.pg
Provided the \fIname\fR is not defined elsewhere,
this state%ment is equivalent to
.pg
.ti 6
.li
.globl  name
.ti 6
name = expression ^ name
.pg
That is, the type of \fIname\fR
is ``undefined external'', and its value is \fIexpression\fR.
In fact the \fIname\fR behaves
in the current assembly just like an
undefined external.
However, the link-editor \fIld\fR has been special-cased
so that all external symbols which are not
otherwise defined, and which have a non-zero
value, are defined to lie in the bss
segment, and enough space is left after the
symbol to hold \fIexpression\fR
bytes.
All symbols which become defined in this way
are located before all the explicitly defined
bss-segment locations.
.ul
8.   Machine instructions
.et
Because of the rather complicated instruction and addressing
structure of the \s8PDP\s10-11, the syntax of machine instruction
state%ments is varied.
Although the following sections give the syntax
in detail, the 11/20 and 11/45 handbooks should
be consulted on the semantics.
.ms
8.1  Sources and Destinations
.pg
The syntax of general source and destination
addresses is the same.
Each must have one of the following forms,
where \fIreg\fR is a register symbol, and \fIexpr\fR
is any sort of expression:
.sp
.ne 17
.nf
.ta .75i 1.825i 2.75i
	syntax	words	mode
.ta .75i 2.75i+\w'0+reg'u
.lc \(ru
8	\(ru9
.ft R
.ta  .75i 2.0i 2.75i
	\fIreg\fR	0	0+\fIreg\fB
	(\|\fIreg\fB\|)\|+	\fR0	2+\fIreg\fB
	_\|(\|\fIreg\fB\|)	\fR0	4+\fIreg\fR
	\fIexpr\|\fB(\|\fIreg\fB\|)	\fR1	6+\fIreg\fB
	(\|\fIreg\fB\|)	\fR0	1+\fIreg\fB
	*\|\fIreg\fB	\fR0	1+\fIreg\fB
	*\|(\|\fIreg\fB\|)\|+	\fR0	3+\fIreg\fB
	*\|_\|(\|\fIreg\fB\|)	\fR0	5+\fIreg\fB
	*\|(\|\fIreg\fB\|)	\fR1	7+\fIreg\fB
	*\|\fIexpr\fB\|(\|\fIreg\fB\|)	\fR1	7+\fIreg\fB
	\fIexpr	\fR1	67
	\fB$\|\fIexpr	\fR1	27
	\fB*\|\fIexpr	\fR1	77
	\fB*\|$\|\fIexpr	\fR1	37
.sp
.fi
The \fIwords\fR column gives the number of address words generated;
the \fImode\fR column gives the octal address-mode number.
The syntax of the address forms is
identical to that in \s8DEC\s10 assemblers, except that ``*'' has
been substituted for ``@''
and ``$'' for ``#''; the \s8UNIX\s10 typing conventions make ``@'' and ``#''
rather inconvenient.
.br
.pg
Notice that mode ``*reg'' is identical to ``(reg)'';
that ``*(reg)'' generates an index word (namely, 0);
and that addresses consisting of an unadorned expression
are assembled as pc-relative ref%er%ences independent
of the type of the expression.
To force a non-relative ref%er%ence, the form ``*$expr'' can
be used, but notice that further indirection is impossible.
.ms
8.3  Simple machine instructions
.pg
The following instructions
are defined as absolute symbols:
.pg
.ta 1i 2.5i 3i
.ne  8
.nf
.ft B
	clc
	clv
	clz
	cln
	sec
	sev
	sez
	sen
.pg
.fi
.ft R
They therefore require
no special syntax.
The \s8PDP\s10-11 hardware allows more than one of the ``clear''
class, or alternatively more than one of the ``set'' class
to be \fBor\fR-ed together; this may be expressed as follows:
.pg
	clc\|\|\|\(bv\|\|clv
.ms
8.4  Branch
.pg
The following instructions take an expression as operand.
The expression must lie in the same segment as the ref%er%ence,
cannot be undefined-external,
and its value cannot differ from the current location of ``\|\fB.\fP\|''
by more than 254 bytes:
.pg
.ne 10
.nf
.ft B
	br	blos
	bne	bvc
	beq	bvs
	bge	bhis
	blt	bec	\fR(=\fB bcc\fR)\fB
	bgt	bcc
	ble	blo
	bpl	bcs
	bmi	bes	\fR(=\fB bcs\fR)\fB
	bhi
.pg
.fi
.ft R
\fBbes\fR (``branch on error set'')
and \fBbec\fR (``branch on error clear'')
are intended to test the error bit
returned by system calls (which
is the c-bit).
.ms
8.5   Extended branch instructions
.pg
The following symbols are followed by an expression
representing an address
in the same segment as ``\|\fB.\|\fP''.
If the target address is close enough,
a branch-type instruction is generated;
if the address is too far away,
a \fBjmp\fR will be used.
.pg
.ne 10
.nf
.ft B
	jbr	jlos
	jne	jvc
	jeq	jvs
	jge	jhis
	jlt	jec
	jgt	jcc
	jle	jlo
	jpl	jcs
	jmi	jes
	jhi
.pg
.fi
.ft R
\fBjbr\fR turns into a plain \fBjmp\fR
if its target is too remote;
the others (whose names are contructed
by replacing the ``b'' in the branch instruction's
name by ``j''\|)
turn into the converse branch over a \fBjmp\fR
to the target address.
.ms
8.6  Single operand instructions
.pg
The following
symbols are names of single-operand
machine instructions.
The form
of address expected is discussed in \(sc8.1 above.
.pg
.ft B
.nf
	clr	sbcb
	clrb	ror
	com	rorb
	comb	rol
	inc	rolb
	incb	asr
	dec	asrb
	decb	asl
	neg	aslb
	negb	jmp
	adc	swab
	adcb	tst
	sbc	tstb
.br
.ft R
.fi
.ms
8.7  Double operand instructions
.pg
The following instructions take a general source
and destination (\(sc8.1), separated by a comma, as operands.
.pg
.ne 12
.ft B
.nf
	mov
	movb
	cmp
	cmpb
	bit
	bitb
	bic
	bicb
	bis
	bisb
	add
	sub
.fi
.ft R
.ms
8.8  Miscellaneous instructions
.pg
The following instructions have
more specialized syntax.
Here \fIreg\fR is
a register name, \fIsrc\fR and \fIdst\fR a general source
or destination
(\(sc8.1), and \fIexpr\fR is an expression:
.pg
.nf
.ta 1.0i 1.5i 3i
\fB	jsr\fI	reg,dst
\fB	rts\fI	reg
\fB	sys\fI	expr
.ft B
	ash	\fIsrc\|,\|reg	\fR(or, \fBals\fR)\fB
	ashc	\fIsrc\|,\|reg	\fR(or, \fBalsc\fR)\fB
	mul	\fIsrc\|,\|reg	\fR(or, \fBmpy\fR)\fB
	div	\fIsrc\|,\|reg	\fR(or, \fBdvd\fR)\fR
\fB	xor	\fIreg\|,\|dst\fB
	sxt	\fIdst\fB
	mark	\fIexpr\fB
	sob	\fIreg\|,\|expr\fB
.pg
.ft R
.fi
\fBsys\fR is another name for the \fBtrap\fR instruction.
It is used to code system calls.
Its operand is required to be expressible in 6 bits.
The alternative forms for \fBash\fR, \fBashc\fR, \fBmul\fR, and \fBdiv\fR
are provided to avoid conflict with \s8EAE\s10 register
names should they be needed.
.pg
The expression in \fBmark\fR must be expressible
in six bits, and the expression in \fBsob\fR must
be in the same segment as ``\fB\|.\|\fR'',
must not be external-undefined, must be less than ``\|\fB.\fR\|'',
and must be within 510 bytes of ``\|\fB.\fR\|''.
.ms
8.9  Floating-point unit instructions
.pg
The following floating-point operations are defined,
with syntax as indicated:
.pg
.nf
\fB	cfcc
\fB	setf
\fB	setd
\fB	seti
\fB	setl
\fB	clrf	\fIfdst
\fB	negf	\fIfdst
\fB	absf	\fIfdst
\fB	tstf	\fIfsrc
\fB	movf	\fIfsrc,\|freg	\fR(= ldf\fR\|)
\fB	movf	\fIfreg,\|fdst	\fR(= stf\fR\|)
\fB	movif	\fIsrc,\|freg	\fR(= ldcif\fR\|)
\fB	movfi	\fIfreg,\|dst	\fR(= stcfi\fR\|)
\fB	movof	\fIfsrc,\|freg	\fR(= ldcdf\fR\|)
\fB	movfo	\fIfreg,\|fdst	\fR(= stcfd\fR\|)
\fB	movie	\fIsrc,\|freg	\fR(= ldexp\fR)
\fB	movei	\fIfreg,\|dst	\fR(= stexp\fR)
\fB	addf	\fIfsrc,\|freg
\fB	subf	\fIfsrc,\|freg
\fB	mulf	\fIfsrc,\|freg
\fB	divf	\fIfsrc,\|freg
\fB	cmpf	\fIfsrc,\|freg
\fB	modf	\fIfsrc,\|freg
\fB	ldfps	\fIsrc
\fB	stfps	\fIdst
\fB	stst	\fIdst
.fi
.ft R
.pg
\fIfsrc\fR, \fIfdst\fR, and \fIfreg\fR mean floating-point
source, destination, and register respectively.
Their syntax is identical to that for
their non-floating counterparts, but
note that only
floating registers 0_3 can be a \fIfreg\fR.
.pg
The names of several of the operations
have been changed to bring out an analogy with
certain fixed-point instructions.
The only strange case is \fBmovf\fR, which turns into
either \fBstf\fR or \fBldf\fR
depending respectively on whether its first operand is
or is not a register.
Warning:  \fBldf\fR sets the floating condition codes,
\fBstf\fR does not.
.ul
9.  Other symbols
.et
.ti 0
9.1  \fB.\|.\fR
.pg
The symbol ``\fB\|.\|.\|\fR''
is the
\fIrelocation counter\fR.
Just before each assembled word is placed in the output stream,
the current value of this symbol is added to the word
if the word refers to a text, data or bss segment location.
If the output word is a pc-relative address word
which refers to an absolute location,
the value of ``\fB\|.\|.\|\fR'' is subtracted.
.pg
Thus the value of ``\fB\|.\|.\|\fR'' can be taken to mean
the starting core location of the program.
In \s8UNIX\s10 systems with relocation hardware,
the initial value of ``\|\fB.\|.\fR\|'' is 0.
.pg
The value of ``\|\fB.\|.\fR\|'' may be changed by assignment.
Such a course of action is sometimes
necessary, but the consequences
should be carefully thought out.
It is particularly ticklish
to change ``\|\fB.\|.\fR\|'' midway in an assembly
or to do so in a program which will
be treated by the loader, which has
its own notions of ``\|\fB.\|.\fR\|''.
.ms
9.2  System calls
.pg
The following absolute
symbols may be used to code calls to the \s8UNIX\s10 system
(see the \fBsys\fR instruction above).
.pg
.ft B
.nf
.ta 1i 2.5i
	break	nice
	chdir	open
	chmod	read
	chown	seek
	close	setuid
	creat	signal
	exec	stat
	exit	stime
	fork	stty
	fstat	tell
	getuid	time
	gtty	umount
	link	unlink
	makdir	wait
	mdate	write
	mount
.fi
.ft R
.pg
Warning: the \fBwait\fR system call is not the same
as the \fBwait\fR instruction, which is not defined
in the assembler.
.ul
10.  Diagnostics
.et
When
an input file cannot be read, its name
followed by a question mark is typed and assembly
ceases.
When syntactic or semantic errors occur, a single-character diagnostic is typed out
together with the line number and the file name in which it
occurred.  Errors in pass 1 cause cancellation of pass 2.
The possible errors are:
.sp
.nf
.ta .5i .8i
	)	 parentheses error
	]	 parentheses error
	>	 string not terminated properly
	*	 indirection (\|*\|) used illegally
	\fB.\fR	 illegal assignment to ``\|\fB.\fP\|''
\s8	A\s10	 error in address
\s8	B\s10	 branch address is odd or too remote
\s8	E\s10	 error in expression
\s8	F\s10	 error in local (``f\|'' or ``b'') type symbol
\s8	G\s10	 garbage (unknown) character
\s8	I\s10	 end of file inside an \fB.if\fR
\s8	M\s10	 multiply defined symbol as label
\s8	O\s10	 word quantity assembled at odd address
\s8	P\s10	 phase error_ ``\|\fB.\fP\|'' different in pass 1 and 2
\s8	R\s10	 relocation error
\s8	U\s10	 undefined symbol
\s8	X\s10	 syntax error
.fi
